## 基本线性查找法

- 一个一个找到自己需要的元素
- 可通过索引，通过比对找出所需要的数字

输入：数组，和目标元素

输出：目标元素所在的索引：若不存在。返回-1

## 

## 使用泛型的基本线性查找法

基本线性查找法只能查找我们设置的类型的数组，而用户输入的数组有多种类型，如果一个类型的数组使用一个算法，代码会很冗长。

- 改进方法：使用泛型



##  循环不变量

- 定义：每一轮循环开始前，data[0...i-1]没有找到目标

循坏体维持循环不变量

可“证明”算法的正确性

写出正确的代码

- 定义清楚循环不变量
- 维护循环不变量
- 对于函数，定义清楚函数的功能
  - 如LinearSearch
  - 输入：数组，和目标元素
  - 输出目标元素所在的索引；若不存在，返回-1



## 复杂度分析

表示算法的性能

通常看最差的情况，算法运行的上界

算法分析时，常数不重要。因为复杂度描述的时随着数据规模n的增大，算法性能的变化趋势

 用 0() 表达算法性能和数据规模之间的关系



## 常见的算法复杂度

1. 0(n) 如线性查找
2. O(n^2) 如遍历一个n*n的二维数组
3. O(logn) （不关注底为多少）如数字n的二进制位数
4. O(根号n) 如数字n的所有约数
5. O(2^n) 如长度为n的二进制数
6. O(n!) 如长度为n的数组的所有排列
7. 7.O(1) 如判断数字n是否是偶数

复杂度大小关系

0(1)<O(longn)<O(根号n)<O(n)<O(nlogn)<O(n^2)<O(2^n)<O(n!)



## 代码

基本线性查找

```c
#include <stdio.h>

int LinearSearch(int *num,int length,int target){
    for(int i=0;i<length;i++)
    {
        if(num[i] == target)
        {
            return i;
        }
    }
    return -1;
}
int main()
{
    int num[6] = {1,2,4,6,7,8};
    int res1=LinearSearch(num,6,4);
    printf("查找4，位置为:%d\n",res1);
    int res2=LinearSearch(num,6,3);
    printf("查找3，位置为:%d",res2);
    return 0;

}

```



使用泛型的线性查找

```c
#include <stdio.h>
#include <string.h>

void* LinearSearch2( void *base,void* key,int n, int elemSize){
    for(int i = 0;i < n; ++i){
        void *elemAddr = (char *)base+i*elemSize;
        if(memcmp(key, elemAddr, elemSize) == 0)
            return i;
    }
    return -1;
}

int main()
{
    int num[] = {1,2,4,6,7,8};
    int size=6;
    int number1=4;
    int *res1=LinearSearch2(num,&number1,size,sizeof(int));
    printf("查找4，位置为:%d\n",res1);

    int number2=5;
    int *res2=LinearSearch2(num,&number2,size,sizeof(int));
    printf("查找5，位置为:%d\n",res2);

    
    return 0;

}
```

